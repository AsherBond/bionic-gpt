// @generated by protobuf-ts 2.2.2
// @generated from protobuf file "api.proto" (package "vault", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message vault.Secret
 */
export interface Secret {
    /**
     * @generated from protobuf field: string encrypted_name = 1;
     */
    encryptedName: string;
    /**
     * @generated from protobuf field: string name_blind_index = 2;
     */
    nameBlindIndex: string;
    /**
     * @generated from protobuf field: string encrypted_secret_value = 3;
     */
    encryptedSecretValue: string;
    /**
     * @generated from protobuf field: uint32 environment_id = 4;
     */
    environmentId: number;
}
/**
 * @generated from protobuf message vault.ServiceAccount
 */
export interface ServiceAccount {
    /**
     * @generated from protobuf field: uint32 service_account_id = 1;
     */
    serviceAccountId: number;
    /**
     * @generated from protobuf field: uint32 environment_id = 2;
     */
    environmentId: number;
    /**
     * @generated from protobuf field: string public_ecdh_key = 3;
     */
    publicEcdhKey: string;
}
/**
 * @generated from protobuf message vault.ServiceAccountSecrets
 */
export interface ServiceAccountSecrets {
    /**
     * @generated from protobuf field: uint32 service_account_id = 1;
     */
    serviceAccountId: number;
    /**
     * @generated from protobuf field: repeated vault.Secret secrets = 2;
     */
    secrets: Secret[];
    /**
     * The ECDH ethereal public key that was used as part of
     * the key agreement to encrypt these secrets
     *
     * @generated from protobuf field: string public_ecdh_key = 3;
     */
    publicEcdhKey: string;
}
/**
 * @generated from protobuf message vault.GetServiceAccountRequest
 */
export interface GetServiceAccountRequest {
    /**
     * @generated from protobuf field: string ecdh_public_key = 1;
     */
    ecdhPublicKey: string;
}
/**
 * @generated from protobuf message vault.ServiceAccountSecret
 */
export interface ServiceAccountSecret {
    /**
     * @generated from protobuf field: string encrypted_name = 1;
     */
    encryptedName: string;
    /**
     * @generated from protobuf field: string name_blind_index = 2;
     */
    nameBlindIndex: string;
    /**
     * @generated from protobuf field: string encrypted_secret_value = 3;
     */
    encryptedSecretValue: string;
    /**
     * @generated from protobuf field: string ecdh_public_key = 4;
     */
    ecdhPublicKey: string;
}
/**
 * @generated from protobuf message vault.GetServiceAccountResponse
 */
export interface GetServiceAccountResponse {
    /**
     * @generated from protobuf field: uint32 service_account_id = 1;
     */
    serviceAccountId: number;
    /**
     * @generated from protobuf field: repeated vault.ServiceAccountSecret secrets = 3;
     */
    secrets: ServiceAccountSecret[];
}
/**
 * @generated from protobuf message vault.GetVaultRequest
 */
export interface GetVaultRequest {
    /**
     * @generated from protobuf field: uint32 vault_id = 1;
     */
    vaultId: number;
}
/**
 * @generated from protobuf message vault.GetVaultResponse
 */
export interface GetVaultResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The users encrypted copy of the vault key
     *
     * @generated from protobuf field: string user_vault_encrypted_vault_key = 2;
     */
    userVaultEncryptedVaultKey: string;
    /**
     * The users public ECDH key for the vault so the can
     * use a key agreement to decrypt thew vault key
     *
     * @generated from protobuf field: string user_vault_public_ecdh_key = 3;
     */
    userVaultPublicEcdhKey: string;
    /**
     * All of the secrets encrypted with the vault key
     *
     * @generated from protobuf field: repeated vault.Secret secrets = 4;
     */
    secrets: Secret[];
    /**
     * @generated from protobuf field: repeated vault.ServiceAccount service_accounts = 5;
     */
    serviceAccounts: ServiceAccount[];
}
/**
 * @generated from protobuf message vault.CreateSecretsRequest
 */
export interface CreateSecretsRequest {
    /**
     * @generated from protobuf field: repeated vault.ServiceAccountSecrets account_secrets = 1;
     */
    accountSecrets: ServiceAccountSecrets[];
}
/**
 * @generated from protobuf message vault.CreateSecretsResponse
 */
export interface CreateSecretsResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class Secret$Type extends MessageType<Secret> {
    constructor() {
        super("vault.Secret", [
            { no: 1, name: "encrypted_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name_blind_index", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "encrypted_secret_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "environment_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Secret>): Secret {
        const message = { encryptedName: "", nameBlindIndex: "", encryptedSecretValue: "", environmentId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Secret>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Secret): Secret {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string encrypted_name */ 1:
                    message.encryptedName = reader.string();
                    break;
                case /* string name_blind_index */ 2:
                    message.nameBlindIndex = reader.string();
                    break;
                case /* string encrypted_secret_value */ 3:
                    message.encryptedSecretValue = reader.string();
                    break;
                case /* uint32 environment_id */ 4:
                    message.environmentId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Secret, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string encrypted_name = 1; */
        if (message.encryptedName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.encryptedName);
        /* string name_blind_index = 2; */
        if (message.nameBlindIndex !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nameBlindIndex);
        /* string encrypted_secret_value = 3; */
        if (message.encryptedSecretValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.encryptedSecretValue);
        /* uint32 environment_id = 4; */
        if (message.environmentId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.environmentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vault.Secret
 */
export const Secret = new Secret$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceAccount$Type extends MessageType<ServiceAccount> {
    constructor() {
        super("vault.ServiceAccount", [
            { no: 1, name: "service_account_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "environment_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "public_ecdh_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceAccount>): ServiceAccount {
        const message = { serviceAccountId: 0, environmentId: 0, publicEcdhKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceAccount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceAccount): ServiceAccount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 service_account_id */ 1:
                    message.serviceAccountId = reader.uint32();
                    break;
                case /* uint32 environment_id */ 2:
                    message.environmentId = reader.uint32();
                    break;
                case /* string public_ecdh_key */ 3:
                    message.publicEcdhKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceAccount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 service_account_id = 1; */
        if (message.serviceAccountId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.serviceAccountId);
        /* uint32 environment_id = 2; */
        if (message.environmentId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.environmentId);
        /* string public_ecdh_key = 3; */
        if (message.publicEcdhKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publicEcdhKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vault.ServiceAccount
 */
export const ServiceAccount = new ServiceAccount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceAccountSecrets$Type extends MessageType<ServiceAccountSecrets> {
    constructor() {
        super("vault.ServiceAccountSecrets", [
            { no: 1, name: "service_account_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Secret },
            { no: 3, name: "public_ecdh_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceAccountSecrets>): ServiceAccountSecrets {
        const message = { serviceAccountId: 0, secrets: [], publicEcdhKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceAccountSecrets>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceAccountSecrets): ServiceAccountSecrets {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 service_account_id */ 1:
                    message.serviceAccountId = reader.uint32();
                    break;
                case /* repeated vault.Secret secrets */ 2:
                    message.secrets.push(Secret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string public_ecdh_key */ 3:
                    message.publicEcdhKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceAccountSecrets, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 service_account_id = 1; */
        if (message.serviceAccountId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.serviceAccountId);
        /* repeated vault.Secret secrets = 2; */
        for (let i = 0; i < message.secrets.length; i++)
            Secret.internalBinaryWrite(message.secrets[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string public_ecdh_key = 3; */
        if (message.publicEcdhKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publicEcdhKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vault.ServiceAccountSecrets
 */
export const ServiceAccountSecrets = new ServiceAccountSecrets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetServiceAccountRequest$Type extends MessageType<GetServiceAccountRequest> {
    constructor() {
        super("vault.GetServiceAccountRequest", [
            { no: 1, name: "ecdh_public_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetServiceAccountRequest>): GetServiceAccountRequest {
        const message = { ecdhPublicKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetServiceAccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetServiceAccountRequest): GetServiceAccountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ecdh_public_key */ 1:
                    message.ecdhPublicKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetServiceAccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ecdh_public_key = 1; */
        if (message.ecdhPublicKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ecdhPublicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vault.GetServiceAccountRequest
 */
export const GetServiceAccountRequest = new GetServiceAccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceAccountSecret$Type extends MessageType<ServiceAccountSecret> {
    constructor() {
        super("vault.ServiceAccountSecret", [
            { no: 1, name: "encrypted_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name_blind_index", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "encrypted_secret_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ecdh_public_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceAccountSecret>): ServiceAccountSecret {
        const message = { encryptedName: "", nameBlindIndex: "", encryptedSecretValue: "", ecdhPublicKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceAccountSecret>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceAccountSecret): ServiceAccountSecret {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string encrypted_name */ 1:
                    message.encryptedName = reader.string();
                    break;
                case /* string name_blind_index */ 2:
                    message.nameBlindIndex = reader.string();
                    break;
                case /* string encrypted_secret_value */ 3:
                    message.encryptedSecretValue = reader.string();
                    break;
                case /* string ecdh_public_key */ 4:
                    message.ecdhPublicKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceAccountSecret, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string encrypted_name = 1; */
        if (message.encryptedName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.encryptedName);
        /* string name_blind_index = 2; */
        if (message.nameBlindIndex !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nameBlindIndex);
        /* string encrypted_secret_value = 3; */
        if (message.encryptedSecretValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.encryptedSecretValue);
        /* string ecdh_public_key = 4; */
        if (message.ecdhPublicKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ecdhPublicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vault.ServiceAccountSecret
 */
export const ServiceAccountSecret = new ServiceAccountSecret$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetServiceAccountResponse$Type extends MessageType<GetServiceAccountResponse> {
    constructor() {
        super("vault.GetServiceAccountResponse", [
            { no: 1, name: "service_account_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServiceAccountSecret }
        ]);
    }
    create(value?: PartialMessage<GetServiceAccountResponse>): GetServiceAccountResponse {
        const message = { serviceAccountId: 0, secrets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetServiceAccountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetServiceAccountResponse): GetServiceAccountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 service_account_id */ 1:
                    message.serviceAccountId = reader.uint32();
                    break;
                case /* repeated vault.ServiceAccountSecret secrets */ 3:
                    message.secrets.push(ServiceAccountSecret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetServiceAccountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 service_account_id = 1; */
        if (message.serviceAccountId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.serviceAccountId);
        /* repeated vault.ServiceAccountSecret secrets = 3; */
        for (let i = 0; i < message.secrets.length; i++)
            ServiceAccountSecret.internalBinaryWrite(message.secrets[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vault.GetServiceAccountResponse
 */
export const GetServiceAccountResponse = new GetServiceAccountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVaultRequest$Type extends MessageType<GetVaultRequest> {
    constructor() {
        super("vault.GetVaultRequest", [
            { no: 1, name: "vault_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetVaultRequest>): GetVaultRequest {
        const message = { vaultId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetVaultRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVaultRequest): GetVaultRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 vault_id */ 1:
                    message.vaultId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVaultRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 vault_id = 1; */
        if (message.vaultId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.vaultId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vault.GetVaultRequest
 */
export const GetVaultRequest = new GetVaultRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVaultResponse$Type extends MessageType<GetVaultResponse> {
    constructor() {
        super("vault.GetVaultResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_vault_encrypted_vault_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_vault_public_ecdh_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Secret },
            { no: 5, name: "service_accounts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServiceAccount }
        ]);
    }
    create(value?: PartialMessage<GetVaultResponse>): GetVaultResponse {
        const message = { name: "", userVaultEncryptedVaultKey: "", userVaultPublicEcdhKey: "", secrets: [], serviceAccounts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetVaultResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVaultResponse): GetVaultResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string user_vault_encrypted_vault_key */ 2:
                    message.userVaultEncryptedVaultKey = reader.string();
                    break;
                case /* string user_vault_public_ecdh_key */ 3:
                    message.userVaultPublicEcdhKey = reader.string();
                    break;
                case /* repeated vault.Secret secrets */ 4:
                    message.secrets.push(Secret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated vault.ServiceAccount service_accounts */ 5:
                    message.serviceAccounts.push(ServiceAccount.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVaultResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string user_vault_encrypted_vault_key = 2; */
        if (message.userVaultEncryptedVaultKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userVaultEncryptedVaultKey);
        /* string user_vault_public_ecdh_key = 3; */
        if (message.userVaultPublicEcdhKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userVaultPublicEcdhKey);
        /* repeated vault.Secret secrets = 4; */
        for (let i = 0; i < message.secrets.length; i++)
            Secret.internalBinaryWrite(message.secrets[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated vault.ServiceAccount service_accounts = 5; */
        for (let i = 0; i < message.serviceAccounts.length; i++)
            ServiceAccount.internalBinaryWrite(message.serviceAccounts[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vault.GetVaultResponse
 */
export const GetVaultResponse = new GetVaultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSecretsRequest$Type extends MessageType<CreateSecretsRequest> {
    constructor() {
        super("vault.CreateSecretsRequest", [
            { no: 1, name: "account_secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServiceAccountSecrets }
        ]);
    }
    create(value?: PartialMessage<CreateSecretsRequest>): CreateSecretsRequest {
        const message = { accountSecrets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateSecretsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSecretsRequest): CreateSecretsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vault.ServiceAccountSecrets account_secrets */ 1:
                    message.accountSecrets.push(ServiceAccountSecrets.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSecretsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vault.ServiceAccountSecrets account_secrets = 1; */
        for (let i = 0; i < message.accountSecrets.length; i++)
            ServiceAccountSecrets.internalBinaryWrite(message.accountSecrets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vault.CreateSecretsRequest
 */
export const CreateSecretsRequest = new CreateSecretsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSecretsResponse$Type extends MessageType<CreateSecretsResponse> {
    constructor() {
        super("vault.CreateSecretsResponse", []);
    }
    create(value?: PartialMessage<CreateSecretsResponse>): CreateSecretsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateSecretsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSecretsResponse): CreateSecretsResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CreateSecretsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vault.CreateSecretsResponse
 */
export const CreateSecretsResponse = new CreateSecretsResponse$Type();
/**
 * @generated ServiceType for protobuf service vault.Vault
 */
export const Vault = new ServiceType("vault.Vault", [
    { name: "GetServiceAccount", options: {}, I: GetServiceAccountRequest, O: GetServiceAccountResponse },
    { name: "GetVault", options: {}, I: GetVaultRequest, O: GetVaultResponse },
    { name: "CreateSecrets", options: {}, I: CreateSecretsRequest, O: CreateSecretsResponse }
]);
